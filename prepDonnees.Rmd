---
title: "Préparation des données"
output:
  html_document:
    number_sections: yes
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval  = TRUE)
knitr::opts_chunk$set(echo  = TRUE)
knitr::opts_chunk$set(warning  = FALSE)
``` 


# Objectif

Pour l'examen (y compris celui de rattrapage), on extrait pour chaque ville choisie par les étudiants :

- les données foncières à la parcelle

- l'enquête filosofi au carreau

- le recensement à l'iris

- le rpls à l'appartement


Ces 4 sources seront utilisées pour le devoir maison, afin de permettre à l'étudiant de choisir.

Ces 4 sources seront agrégées au bureau de vote via les centroides pour l'élection de 2022 (on dispose des bureaux uniquement pour cette élection)

# Extraction des données

## résultats des élections 2022

Chaque étudiant a choisi une ville pour ses données. Ces villes sont choisies au cours2,
jusqu'au cours 9 pour les modifications

Rochefort est rajouté à la main

```{r}
# recup fichier ville
ville <- read.csv("data/cours2.csv", colClasses = "character")
ville <- ville [,3]
villeModif <- read.csv("data/cours3.csv", colClasses = "character")
ville <- c(ville, villeModif [,4])
# recup dernier cours
villeModif <- read.csv("data/cours9.csv", colClasses = "character")
# rajout Rochefort
ville <- c(ville, 17299)
ville <- c(ville, villeModif [,4])
# 76 villes différentes
ville <- unique(na.omit(ville))
# recodage pour le zéro
nb <- nchar(ville)
df <- data.frame(cbind(ville, nb))
df$ville [df$nb == 4 ]<- paste0("0", df$ville [df$nb == 4 ] )
df$nb <- nchar(df$ville)
table(df$nb)
df [(df$nb != 5),]
df <- df [!(df$nb != 5),]
# liste des villes utilisées avec code à 5 chiffres = 73
```


```{r}
library(sf)
library(mapsf)
fr <- st_read("data/gros/COMMUNE_CARTO.shp")
# le code INSEE a 5 chiffres y compris le zéro
names(df)
names(fr)
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
# la jointure est de 68
# pb sur 5 code insee qui doivent etre des cp
cp <- setdiff(df$ville, joint$INSEE_COM)
```

retrouver les code insee à partir des cp pour ces 5 communes
utilisation de l'api

```{r}
library(httr)
library(jsonlite)
equiv <- NULL
for (i in cp){
  rqt <- paste0("https://geo.api.gouv.fr/communes?codePostal=",i)
  res <- httr::GET(rqt)
# dans res, on remarque le status à 200, c'est ok. et le format json
  tmp <- fromJSON(rawToChar(res$content))
  equiv <- rbind(equiv, tmp)
}
str(equiv)
# bizarrement le cp est en liste donc on remet en vecteur et on fait un tab 
# histoire de repérer les doublons cp
equiv$codesPostaux <- unlist(equiv$codesPostaux)
table(equiv$codesPostaux)
equiv <- equiv [, c("code", "nom")]
df <- rbind(df, data.frame(ville=equiv$code, nb = 5))
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
joint <- unique(joint)
```

72 villes récupérées
73 au départ

quelques test

```{r}
joint$NOM_COM_M[grep("ROCHE|ISSY|VITRY|ACH", joint$NOM_COM_M)]
```


```{r, eval=FALSE}
# jointure ville code insee pour les résultats
election2022 <- read.csv("data/gros/resultats-par-niveau-burvot-t1-france-entiere.csv", fileEncoding = "UTF-8", header = T, colClasses = "character")
names(election2022)
str(election2022$Code.de.la.commune)
# transformation en données texte
election2022$INSEE_COM<-paste0(election2022$Code.du.département,election2022$Code.de.la.commune)
# 2e jointure
joint2 <- merge(joint, election2022, by = "INSEE_COM", )
length(unique(joint2$INSEE_COM))
# encore 1 en moins...
fond <- st_read("data/gros/DEPARTEMENT.shp")
png("img/communes.png")
mf_init(joint)
mf_map(fond, add = T, col = "antiquewhite1", border = "wheat")
mf_map(joint, col = "red", border = NA,add = T)
mf_layout("Communes choisies par les étudiants", credits = "IGN")
dev.off()
```

![](img/communes.png)

Des choix sur toute l'étendue du territoire de la métropole


Enregistrement des fichiers

```{r, eval=FALSE}
# pb zéro
joint2$INSEE_COM_TXT <- paste0("'", joint2$INSEE_COM)
joint2$INSEE_COM_TXT
names(joint2)
st_write(joint2 [, c(119,8,19:118)], "data/geo.gpkg", "election2022", fileEncoding ="UTF-8", delete_layer = T)
write.csv(joint2 [, c(119,8, 18:117), drop = T], "data/election2022.csv", fileEncoding = "UTF-8")
```


Bureaux de vote pour chacune des communes, données texte

```{r}
data <- read.csv("data/election2022.csv", fileEncoding = "UTF-8") 
# nb de bv par communes : grande disparité
sort(table(data$INSEE_COM_TXT))
# 71 communes
length(unique(data$INSEE_COM_TXT))
# enregstrement de ces cog
write.csv(unique(data[,c("INSEE_COM_TXT", "Libellé.de.la.commune")]),"data/cog.csv", row.names = F,fileEncoding = "UTF-8")
```

## Valeurs foncières



```{r}
cog <- read.csv("data/cog.csv")
vf <- read.csv("data/gros/valeursfoncieres-2022.txt", sep ="|", dec = ",")
```

attention gros fichier

code INSEE

pb des zéros, un import en txt n'a pas réglé la question.


```{r}
vf$lg <- sapply(vf$Code.commune, nchar)
vf$dpt <- sapply(vf$Code.departement, nchar)
table(vf$dpt)
table(vf$Code.departement [vf$dpt == "3"])
# on supprime les DROM
vf<- vf [vf$dpt < 3, ] 
table(vf$lg, useNA = "always")
vf$com <- paste0('00', vf$Code.commune)
table(sapply(vf$com, nchar))
right = function (string, char) {
    substr(string,nchar(string)-(char-1),nchar(string))
}
vf$comF <- right(vf$com, 3)
table(sapply(vf$comF, nchar))
vf$cog <- paste0("'",vf$Code.departement, vf$comF)
table(sapply(vf$cog, nchar))
```

extraction des 71 communes


```{r}
vfSel <- vf [vf$cog %in% cog$INSEE_COM_TXT,]
length(unique(vfSel$cog))
```

68 communes
On rajoute les premiers arrondissements de Marseille et Lyon

```{r}
manquants <- setdiff(cog$INSEE_COM_TXT, vfSel$cog)
cog$Libellé.de.la.commune [cog$INSEE_COM_TXT %in% manquants]
```

Marseille et Lyon trop grands. Thionville pas de valeur foncière

```{r}
vf [grep("MARSEILLE", vf$Commune), c("cog","Commune")]
# Pour Marseille, on prend le 1er 13201
vf [grep("^THIONVILLE", vf$Commune), c("cog","Commune")]
vf [vf$cog == 57672,]
# Les DVF pour l'Alsace Moselle dans le livre foncier droit local pas d'appli
vf [grep("^LYON", vf$Commune), c("cog","Commune")]
# Pour Lyon, le 69381
manquants <- c("'13201", "'69381")
```

```{r}
autres <- vf [vf$cog %in% manquants,]
vfSel <- rbind(vfSel, autres)
```

test bondy

```{r}
bondy <- vfSel [vfSel$cog == "'93010",]
tab <- table(bondy$Valeur.fonciere)
hist(bondy$Valeur.fonciere)
table(bondy$Voie [bondy$Valeur.fonciere > 30000000])
barplot(table(bondy$Voie [bondy$Valeur.fonciere < 3000]), las = 2)
```

On enregistre le fichier.

```{r}
names(vfSel)
write.csv(vfSel [, c(48,1:43)], "data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
```


on enregistre par dpt


```{r}
valDpt <- unique(vfSel$Code.departement)
for (i in valDpt){
  sel <- vfSel [vfSel$Code.departement == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/vf/", i, "_vfEXAMEN.csv"), fileEncoding = "UTF-8")
}
```



##  Base logement (IRIS)



```{r}
lgt <- read.csv2("data/gros/base-ic-logement-2019.CSV", dec = ".")
lgt$INSEE_CODE_TXT <- paste0("'", lgt$COM)
# rajout Marseille 1 et Lyon 1 13201 69381
ajout1 <- c("'13201", "Marseille 1")
ajout2 <- c("'69381", "Lyon 1")
cog <- rbind(cog, ajout1, ajout2)
lgtSel <- lgt [lgt$INSEE_CODE_TXT %in% cog$INSEE_COM_TXT,]
length(unique(lgtSel$COM))
```

71 communes

test Bondy


```{r}
bondy <- lgtSel [lgtSel$COM == '93010',]
plot(bondy$P19_LOGVAC, bondy$P19_MAISON)
```


enregistrement

```{r}
write.csv(lgtSel, "data/gros/lgt.csv", fileEncoding = "UTF-8")
valDpt <- unique(vfSel$Code.departement)
lgtSel$dpt <- substring(lgtSel$COM,1,2)
for (i in valDpt){
  sel <- lgtSel [lgtSel$dpt == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/lgt/", i, "_lgtEXAMEN.csv"), fileEncoding = "UTF-8")
}
```

## Carreaux Filosofi

```{r}
library(sf)
library(mapsf)
car <- st_read("data/gros/carreaux_200m_met.gpkg")
# extraction du premier code insee du carreau + la quote pour pb zero
car$cog <- paste0("'",substring(car$lcog_geo,1,5))
carSel <- car [car$cog %in% cog$INSEE_COM_TXT,]
length(unique(carSel$cog))
```

toujours 71


Bondy


```{r}
bondy <- carSel [carSel$lcog_geo == '93010',]
plot(bondy$men_pauv, bondy$men_mais)
hist(bondy$men_pauv)
str(bondy)
```

Enregistrement des carreaux par dpt

```{r}
st_write(carSel, "data/gros/geo.gpkg", "car", delete_layer = T)
```

16 M carreaux

```{r}
valDpt <- unique(vfSel$Code.departement)
carSel$dpt <- substring(carSel$lcog_geo,1,2)
carSel <- carSel [,c(37,1:33), drop = T]
for (i in valDpt){
  sel <- carSel [carSel$dpt == i,]
  write.csv2(sel, paste0("data/examen/car/", i, "_carEXAMEN.csv"), fileEncoding = "UTF-8")
}
```

## RPLS

Le RPLS est par région et par dpt en idf

```{r}
fic <- list.files("data/gros/RPLS")
regFic <- substring(fic, 28,29)
refRPLS <- data.frame(reg = regFic, fic = fic)
refRPLS
# equiv code insee et region
ref <- read.csv("data/gros/table-appartenance-geo-communes-23.csv", fileEncoding = "UTF-8")
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8")
cog$INSEE_COM <- substring(cog$INSEE_COM_TXT, 2, 6)
joint <- merge(cog, ref [, c("CODGEO", "REG", "DEP")], by.x = "INSEE_COM", by.y = "CODGEO")
reg <-names(table(joint$REG))
# 12 régions sur 19
r <- reg [1]
reg <- reg [-c(1:3)]
rpls <- NULL
for (r in reg){
  refFIC <- refRPLS$fic [refRPLS$reg == r]
  print(r)
  fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), header = T, quote = "")
  commune <- joint$INSEE_COM [joint$REG == r] 
  for (c in commune){
     tmp <-  fic [fic$DEPCOM == c,]
     rpls <- rbind (rpls, tmp)
  }
  }
write.csv(rpls, "data/gros/rpls.csv")
head(rpls)
```

pb lecture reg27

```{r}
fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), quote="")
write.csv(fic, paste0("data/gros/RPLS", refFIC), fileEncoding = "UTF-8", quote = "")
```


Agrégation par point adresse



# Agrégation par bureaux de vote

On a déjà les bv et les carreaux

```{r}
st_layers("data/gros/geo.gpkg")
```


## Spatialisation

lgt.csv à l'IRIS 
vf.csv  à la parcelle
le rpls à l'appartement

```{r}
vf <- read.csv("data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
lgt <- read.csv("data/gros/lgt.csv", fileEncoding = "UTF-8")
rpls <- list.files("data/gros/RPLS")
```


