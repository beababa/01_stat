---
title: "Préparation des données"
output:
  html_document:
    number_sections: yes
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval  = TRUE)
knitr::opts_chunk$set(echo  = TRUE)
knitr::opts_chunk$set(warning  = FALSE)
``` 


# Objectif

Pour l'examen (y compris celui de rattrapage), on extrait pour chaque ville choisie par les étudiants :

- les données foncières à la parcelle

- l'enquête filosofi au carreau

- le recensement à l'iris

- le rpls à l'appartement


Ces 4 sources seront utilisées pour le devoir maison, afin de permettre à l'étudiant de choisir.

Ces 4 sources seront agrégées au bureau de vote via les centroides pour l'élection de 2022 (on dispose des bureaux uniquement pour cette élection)

## Démarche

5 étapes

- on définit le nombre de communes concernées

- extractions pour les fichiers spatiaux et les fichiers texte (diminuer la taille
des fichiers)

- intersection bv et centroides fichiers spatiaux

- jointure attributaire centroide, fichers de données

- agrégation des données au bv


```{r}
library(sf)
library(mapsf)
```


# cog

Définition de la liste des villes de base.

Des pb seront à traiter : Pointe à Pitre, Lyon, Marseille

Chaque étudiant a choisi une ville pour ses données. Ces villes sont choisies au cours2,
jusqu'au cours 9 pour les modifications

Rochefort est rajouté à la main

```{r}
# recup fichier ville
ville <- read.csv("data/cours2.csv", colClasses = "character")
ville <- ville [,3]
villeModif <- read.csv("data/cours3.csv", colClasses = "character")
ville <- c(ville, villeModif [,4])
# recup dernier cours
villeModif <- read.csv("data/cours9.csv", colClasses = "character")
# rajout Rochefort
ville <- c(ville, 17299)
ville <- c(ville, villeModif [,4])
# 76 villes différentes
ville <- unique(na.omit(ville))
# recodage pour le zéro
nb <- nchar(ville)
df <- data.frame(cbind(ville, nb))
df$ville [df$nb == 4 ]<- paste0("0", df$ville [df$nb == 4 ] )
df$nb <- nchar(df$ville)
table(df$nb)
df [(df$nb != 5),]
df <- df [!(df$nb != 5),]
# liste des villes utilisées avec code à 5 chiffres = 73
```


```{r}
fr <- st_read("data/gros/COMMUNE_CARTO.shp")
# le code INSEE a 5 chiffres y compris le zéro
names(df)
names(fr)
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
# la jointure est de 68
# pb sur 5 code insee qui doivent etre des cp
cp <- setdiff(df$ville, joint$INSEE_COM)
```

retrouver les code insee à partir des cp pour ces 5 communes
utilisation de l'api

```{r}
library(httr)
library(jsonlite)
equiv <- NULL
for (i in cp){
  rqt <- paste0("https://geo.api.gouv.fr/communes?codePostal=",i)
  res <- httr::GET(rqt)
# dans res, on remarque le status à 200, c'est ok. et le format json
  tmp <- fromJSON(rawToChar(res$content))
  equiv <- rbind(equiv, tmp)
}
str(equiv)
# bizarrement le cp est en liste donc on remet en vecteur et on fait un tab 
# histoire de repérer les doublons cp
equiv$codesPostaux <- unlist(equiv$codesPostaux)
table(equiv$codesPostaux)
equiv <- equiv [, c("code", "nom")]
df <- rbind(df, data.frame(ville=equiv$code, nb = 5))
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
joint <- unique(joint)
```

72 villes récupérées
73 au départ

quelques tests

sur quelques villes

```{r}
joint$NOM_COM_M[grep("ROCHE|ISSY|VITRY|ACH|POIN", joint$NOM_COM_M)]
```


Pb Lyon et Marseille / uniquement les arrondissements 1

```{r}
joint <- cog
joint$INSEE_COM [joint$INSEE_COM == "13055"] <- "13201"
joint$INSEE_COM [joint$INSEE_COM_TXT == "69123"] <- "69381"



```





premier enregistrement

```{r}
st_write(joint,"data/geo.gpkg", "cog", delete_layer =  T)
write.csv(joint [, c("INSEE_COM", "NOM_COM_M"), drop = T], "data/cog.csv", fileEncoding = "UTF-8", quote = T, row.names = F)
# quote permet d'avoir du texte
# attention on a du DROM Guadeloupe (971) (97120)
```


# Extraction des données









## bv

```{r}
bv <- st_read("data/gros/bureau-de-vote-insee-reu-openstreetmap.gpkg")
bv <- bv [, c("insee", "nom", "bureau")]
bv <- st_transform(bv, 2154)
bvSel <- bv [bv$insee %in% cog$INSEE_COM,]
length(unique(bvSel$insee))
manquants <- setdiff(cog$INSEE_COM, bv$insee)
```

pb Marseille 1er 

les codes insee sont les codes des villes (le code arr est sur le champs bureau)

```{r}
bv [bv$insee == '13201',]
marseille <- bv [bv$nom == 'Marseille',]
marseille$insee <- substring(marseille$bureau, 1,5)
marseille <- marseille [marseille$insee == "13201",]
bvSel <- rbind(bvSel, marseille)
```

enregistrement

```{r}
st_write(bvSel, "data/geo.gpkg", "bv", delete_layer = T)
```

## Iris


```{r}
iris <- st_read("data/gros/IRIS-GE_3-0_SHP_LAMB93_FXX-ED2023-01-01/IRIS.shp")
```

```{r}
names(iris)
iris$INSEE_COM
irisSel <- iris [iris$INSEE_COM %in% cog$INSEE_COM,]
length(unique(irisSel$INSEE_COM))
manquants <- setdiff(cog$INSEE_COM, irisSel$INSEE_COM)
cog$NOM_COM_M [cog$INSEE_COM %in% manquants]
```

rajout Pointe à pitre

pb projection....on garde à part

```{r}
iris$NOM_COM
iris <- st_read("data/gros/IRIS-GE_3-0_SHP_RGAF09UTM20_GLP-ED2023-01-01/")
irisSelPAP <- iris [iris$NOM_COM == 'Pointe-à-Pitre',]
```


rajout Lyon si nécessaire

```{r}
iris [grep("^Lyon",iris$NOM_COM),]
manquants <- iris [iris$INSEE_COM == '69381',]     
irisSel <- rbind(irisSel, manquants)
```


enregistrement

```{r}
st_write(irisSel, "data/geo.gpkg", "iris", delete_layer = T)
st_write(irisPAP, "data/geo.gpkg", "irisPAP", delete_layer = T)
```



## résultats des élections 2022



```{r, eval=FALSE}
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8", colClasses = "character")
# jointure ville code insee pour les résultats
election2022 <- read.csv("data/gros/resultats-par-niveau-burvot-t1-france-entiere.csv", fileEncoding = "UTF-8", header = T, colClasses = "character")
names(election2022)
str(election2022$Code.de.la.commune)
# INSEE_COM code insee
election2022$INSEE_COM<-paste0(election2022$Code.du.département,election2022$Code.de.la.commune)
# Pb pointe à pitre
election2022[grep("Pointe-à-Pitre", election2022$Libellé.de.la.commune),]
# le code dpt est ZA120 on le remplace par le cog officiel
election2022$INSEE_COM[election2022$INSEE_COM =="ZA120"] <- 97120
# jointure
joint <- merge(cog, election2022, by = "INSEE_COM")
length(unique(joint$INSEE_COM))
# 72 youpi au cas où ce n'est pas le cas :
pb <- setdiff(cog$INSEE_COM, joint$INSEE_COM)
cog[cog$INSEE_COM %in% pb ,]
```

```{r}
write.csv(election2022,"data/election2022.csv", fileEncoding = "UTF-8", row.names = FALSE)
```



remplacer les en têtes par les noms, on extrait les candidats

le remplacement se fera en fonction des colonnes choisies % ou inscrits ou sexe etc...

```{r}
election2022 <- read.csv("data/election2022.csv", fileEncoding = "UTF-8")
ind <- grep("Nom", names(election2022))
candidats  <- t(unique(election2022[, c(ind)]))
candidats <- as.vector(candidats)
write.csv(candidats,"data/candidats.csv")
```




Cartographie (sans Pointe à Pitre)

```{r}
cogGEOM <- st_read("data/geo.gpkg", "cog") 
cogGEOM <- cogGEOM [-72,]
```


```{r, eval=FALSE}
fond <- st_read("data/gros/DEPARTEMENT.shp")
png("img/communes.png")
mf_init(cogGEOM)
mf_map(fond, add = T, col = "antiquewhite1", border = "wheat")
mf_map(cogGEOM, col = "red", border = NA,add = T)
mf_layout("Communes choisies par les étudiants (sf Pointe à Pitre (Guadeloupe))", credits = "IGN")
dev.off()
```

![](img/communes.png)

Des choix sur toute l'étendue du territoire de la métropole








## Valeurs foncières



```{r}
cog <- read.csv("data/cog.csv", colClasses = "character", fileEncoding = "UTF-8")
cog$INSEE_COM
vf <- read.csv("data/gros/valeursfoncieres-2022.txt", sep ="|", dec = ",", fileEncoding = "UTF-8")
```

attention gros fichier

code INSEE

pb des zéros, un import en txt n'a pas réglé la question.


```{r}
names(vf)
vf$lg <- sapply(vf$Code.commune, nchar)
vf$dpt <- sapply(vf$Code.departement, nchar)
table(vf$dpt)
table(vf$Code.departement [vf$dpt == "3"])
# on supprime les  sf pointe à pitre
vf[grep("POINTE A PITRE", vf$Commune),]
vf$dpt[grep("POINTE A PITRE", vf$Commune)] <-  2
vf<- vf [vf$dpt < 3, ] 
table(vf$lg, useNA = "always")
# pour le code commune on rajoute deux zéros et on coupe
vf$com <- paste0('00', vf$Code.commune)
table(sapply(vf$com, nchar))
right = function (string, char) {
    substr(string,nchar(string)-(char-1),nchar(string))
}
vf$comF <- right(vf$com, 3)
table(sapply(vf$comF, nchar))
# cas pointe à pitre
vf$cog <- paste0(vf$Code.departement, vf$comF)
table(sapply(vf$cog, nchar))
vf$cog [nchar(vf$cog)==6] <- "97120"
```

extraction des 72 communes


```{r}
vfSel <- vf [vf$cog %in% cog$INSEE_COM,]
length(unique(vfSel$cog))
```

68 communes
On rajoute les premiers arrondissements de Marseille et Lyon (au cas où mais normalement le cog a été modifie)

```{r}
manquants <- setdiff(cog$INSEE_COM, vfSel$cog)
cog$Libellé.de.la.commune [cog$INSEE_COM %in% manquants]
vfSel [vfSel$cog == '69381',]
vf$cog [grep("^LYON 1", vf$Commune)]
```

Marseille et Lyon trop grands. Thionville pas de valeur foncière

```{r}
vf [grep("MARSEILLE", vf$Commune), c("cog","Commune")]
# Pour Marseille, on prend le 1er 13201
vf [grep("^THIONVILLE", vf$Commune), c("cog","Commune")]
vf [vf$cog == 57672,]
# Les DVF pour l'Alsace Moselle dans le livre foncier droit local pas d'appli
vf [grep("^LYON", vf$Commune), c("cog","Commune")]
# Pour Lyon, le 69381
manquants <- c("13201", "69381")
```

```{r}
autres <- vf [vf$cog %in% manquants,]
vfSel <- rbind(vfSel, autres)
```

test bondy

```{r}
bondy <- vfSel [vfSel$cog == "'93010",]
tab <- table(bondy$Valeur.fonciere)
hist(bondy$Valeur.fonciere)
table(bondy$Voie [bondy$Valeur.fonciere > 30000000])
barplot(table(bondy$Voie [bondy$Valeur.fonciere < 3000]), las = 2)
```





```{r}
names(vfSel)
write.csv(vfSel [, c(48,1:43)], "data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
```


on enregistre par dpt


```{r}
valDpt <- unique(vfSel$Code.departement)
for (i in valDpt){
  sel <- vfSel [vfSel$Code.departement == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/vf/", i, "_vfEXAMEN.csv"), fileEncoding = "UTF-8")
}
```



##  Base logement (IRIS)



```{r}
lgt <- read.csv2("data/gros/base-ic-logement-2019.CSV", dec = ".")
lgt$INSEE_CODE_TXT <- paste0("'", lgt$COM)
# rajout Marseille 1 et Lyon 1 13201 69381
ajout1 <- c("'13201", "Marseille 1")
ajout2 <- c("'69381", "Lyon 1")
cog <- rbind(cog, ajout1, ajout2)
lgtSel <- lgt [lgt$INSEE_CODE_TXT %in% cog$INSEE_COM_TXT,]
length(unique(lgtSel$COM))
```

71 communes

test Bondy


```{r}
bondy <- lgtSel [lgtSel$COM == '93010',]
plot(bondy$P19_LOGVAC, bondy$P19_MAISON)
```


enregistrement

```{r}
write.csv(lgtSel, "data/gros/lgt.csv", fileEncoding = "UTF-8")
valDpt <- unique(vfSel$Code.departement)
lgtSel$dpt <- substring(lgtSel$COM,1,2)
for (i in valDpt){
  sel <- lgtSel [lgtSel$dpt == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/lgt/", i, "_lgtEXAMEN.csv"), fileEncoding = "UTF-8")
}
```

## Carreaux Filosofi

```{r}
library(sf)
library(mapsf)
car <- st_read("data/gros/carreaux_200m_met.gpkg")
# extraction du premier code insee du carreau + la quote pour pb zero
car$cog <- paste0("'",substring(car$lcog_geo,1,5))
carSel <- car [car$cog %in% cog$INSEE_COM_TXT,]
length(unique(carSel$cog))
```

toujours 71


Bondy


```{r}
bondy <- carSel [carSel$lcog_geo == '93010',]
plot(bondy$men_pauv, bondy$men_mais)
hist(bondy$men_pauv)
str(bondy)
```

Enregistrement des carreaux par dpt

```{r}
st_write(carSel, "data/gros/geo.gpkg", "car", delete_layer = T)
```

16 M carreaux

```{r}
valDpt <- unique(vfSel$Code.departement)
carSel$dpt <- substring(carSel$lcog_geo,1,2)
carSel <- carSel [,c(37,1:33), drop = T]
for (i in valDpt){
  sel <- carSel [carSel$dpt == i,]
  write.csv2(sel, paste0("data/examen/car/", i, "_carEXAMEN.csv"), fileEncoding = "UTF-8")
}
```

## RPLS

Le RPLS est par région et par dpt en idf

```{r}
fic <- list.files("data/gros/RPLS")
regFic <- substring(fic, 28,29)
refRPLS <- data.frame(reg = regFic, fic = fic)
refRPLS
# equiv code insee et region
ref <- read.csv("data/gros/table-appartenance-geo-communes-23.csv", fileEncoding = "UTF-8")
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8")
cog$INSEE_COM <- substring(cog$INSEE_COM_TXT, 2, 6)
joint <- merge(cog, ref [, c("CODGEO", "REG", "DEP")], by.x = "INSEE_COM", by.y = "CODGEO")
reg <-names(table(joint$REG))
# 12 régions sur 19
r <- reg [1]
reg <- reg [-c(1:3)]
rpls <- NULL
for (r in reg){
  refFIC <- refRPLS$fic [refRPLS$reg == r]
  print(r)
  fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), header = T, quote = "")
  commune <- joint$INSEE_COM [joint$REG == r] 
  for (c in commune){
     tmp <-  fic [fic$DEPCOM == c,]
     rpls <- rbind (rpls, tmp)
  }
  }
write.csv(rpls, "data/gros/rpls.csv")
head(rpls)
```

pb lecture reg27

```{r}
fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), quote="")
write.csv(fic, paste0("data/gros/RPLS", refFIC), fileEncoding = "UTF-8", quote = "")
```


Agrégation par point adresse



# Agrégation par bureaux de vote

On a déjà les bv et les carreaux

```{r}
st_layers("data/gros/geo.gpkg")
```


## Spatialisation

lgt.csv à l'IRIS 
vf.csv  à la parcelle
le rpls à l'appartement

### données

#### csv

```{r}
vf <- read.csv("data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
lgt <- read.csv("data/gros/lgt.csv", fileEncoding = "UTF-8")
rpls <- list.files("data/gros/RPLS")
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8", colClasses = "character")
```

#### spatiaux



###  vf / parcelle

On récupère le cadastre, on intersecte parcelle et bv et on enregistre le fichier
dans bv.gpkg avec le code insee.

```{r}
dpt <- substring(cog$INSEE_COM_TXT,2,3)
code <- substring(cog$INSEE_COM_TXT,2,6)
bv <- bv [bv$insee %in% code,]
code
dpt <- dpt [1:length(dpt)]
code <- code [1:length(code)]

for (i in 15:length(dpt)){
  nomZIP <- paste0(dpt [i], "_", code [i],".gz")
  nomGEO <- paste0(dpt [i], "_", code [i],".geojson")
  print(paste0(i, "_",nomZIP))
  if (file.exists(nomZIP)==FALSE ){
    fic <- download.file(paste0("https://cadastre.data.gouv.fr/data/etalab-cadastre/2023-07-01/geojson/communes/", dpt [i],"/",code [i],"/cadastre-", code [i],"-parcelles.json.gz"), nomZIP)
  }
  
  exdir <- paste0("data/gros/cadastre/",nomGEO)
  gunzip(nomZIP, exdir, overwrite = T )
  cadastre <- st_read(paste0("data/gros/cadastre/",nomGEO))
  cadastre <- st_transform(cadastre,2154)
  # extraction bv
  bvSel <- bv [bv$insee == code [i],]
  all(sf::st_is_valid(bvSel))
  bvSel <- st_make_valid(bvSel)
  # intersection avec bv
  inter <- st_intersection(bvSel [, c("bureau")], st_centroid( cadastre [, c("section", "numero")]))
  st_write(inter, "data/gros/bv.gpkg", paste0("bv_",code [i]), delete_layer = T)
}
```


bilan

```{r}
st_layers("data/gros/bv.gpkg")
# 64 couches dont bv69381 (lyon) vide
vf <- vf [vf$Code.departement == '69',]
vf$Code.commune [grep('381', vf$Code.commune)]
table(vf$Code.commune)
```



## lgt / iris





Croisement iris / bv

```{r}
inter <- st_intersection(bv, irisSel)
```



```{r}

```

