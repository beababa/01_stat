---
title: "Préparation des données"
output:
  html_document:
    number_sections: yes
    toc: yes
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(eval  = TRUE)
knitr::opts_chunk$set(echo  = TRUE)
knitr::opts_chunk$set(warning  = FALSE)
``` 


# Objectif

Pour l'examen (y compris celui de rattrapage), on extrait pour chaque ville choisie par les étudiants :

- les données foncières à la parcelle

- l'enquête filosofi au carreau

- le recensement à l'iris

- le rpls à l'appartement


Ces 4 sources seront utilisées pour le devoir maison, afin de permettre à l'étudiant de choisir.

Ces 4 sources seront agrégées au bureau de vote via les centroides pour l'élection de 2022 (on dispose des bureaux uniquement pour cette élection)

## Démarche

5 étapes

- on définit le nombre de communes concernées

- extractions pour les fichiers spatiaux et les fichiers texte (diminuer la taille
des fichiers)

- intersection bv et centroides fichiers spatiaux

- jointure attributaire centroide, fichers de données

- agrégation des données au bv


```{r}
library(sf)
library(mapsf)
```


# cog

Définition de la liste des villes de base.

Des pb seront à traiter : Pointe à Pitre, Lyon, Marseille

Chaque étudiant a choisi une ville pour ses données. Ces villes sont choisies au cours2,
jusqu'au cours 9 pour les modifications

Rochefort est rajouté à la main

## Constitution de la liste

```{r}
# recup fichier ville
ville <- read.csv("data/cours2.csv", colClasses = "character")
ville <- ville [,3]
villeModif <- read.csv("data/cours3.csv", colClasses = "character")
ville <- c(ville, villeModif [,4])
# recup dernier cours
villeModif <- read.csv("data/cours9.csv", colClasses = "character")
# rajout Rochefort
ville <- c(ville, 17299)
ville <- c(ville, villeModif [,4])
# 78 villes différentes
ville <- unique(na.omit(ville))
# recodage pour le zéro
nb <- nchar(ville)
df <- data.frame(cbind(ville, nb))
df$ville [df$nb == 4 ]<- paste0("0", df$ville [df$nb == 4 ] )
df$nb <- nchar(df$ville)
table(df$nb)
df [(df$nb != 5),]
df <- df [!(df$nb != 5),]
# liste des villes utilisées avec code à 5 chiffres = 73
```

Les étudiants ont choisi 73 code insee.

Attention, la lecture du code insee peut se faire comme un chiffre et donc la donnée sera faussée.
Toujours vérifier que le code insee est une variable de type alphanumérique.


## Jointure

```{r}
fr <- st_read("data/gros/COMMUNE_CARTO.shp")
# le code INSEE a 5 chiffres y compris le zéro
names(df)
names(fr)
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
# la jointure est de 68
# pb sur 5 code insee qui doivent etre des cp
cp <- setdiff(df$ville, joint$INSEE_COM)
```

retrouver les code insee à partir des cp pour ces 5 communes
utilisation de l'api

```{r}
library(httr)
library(jsonlite)
equiv <- NULL
for (i in cp){
  rqt <- paste0("https://geo.api.gouv.fr/communes?codePostal=",i)
  res <- httr::GET(rqt)
# dans res, on remarque le status à 200, c'est ok. et le format json
  tmp <- fromJSON(rawToChar(res$content))
  equiv <- rbind(equiv, tmp)
}
str(equiv)
# bizarrement le cp est en liste donc on remet en vecteur et on fait un tab 
# histoire de repérer les doublons cp
equiv$codesPostaux <- unlist(equiv$codesPostaux)
table(equiv$codesPostaux)
equiv <- equiv [, c("code", "nom")]
df <- rbind(df, data.frame(ville=equiv$code, nb = 5))
joint <- merge(fr, df, by.x = "INSEE_COM", by.y= "ville")
joint <- unique(joint)
```

72 villes récupérées
73 au départ

quelques tests sur quelques villes

```{r}
joint$NOM_COM_M[grep("ROCHE|ISSY|VITRY|ACH|POIN", joint$NOM_COM_M)]
```

2 points de vigilance :

- Pb Lyon et Marseille / uniquement les arrondissements 1

- Guadeloupe / Pointe à Pitre (DROM 971, code insee ville 97120)

```{r}
# on substitue le codes insee des arrondissements 1 au code insee de la ville
joint$INSEE_COM [joint$INSEE_COM == "13055"] <- "13201"
joint$INSEE_COM [joint$INSEE_COM == "69123"] <- "69381"
joint$INSEE_COM [joint$INSEE_COM == "97120"]
```


premier enregistrement

```{r}
st_write(joint,"data/geo.gpkg", "cog", delete_layer =  T)
write.csv(joint [, c("INSEE_COM", "NOM_COM_M"), drop = T], "data/cog.csv", fileEncoding = "UTF-8", quote = T, row.names = F)
# quote permet d'avoir du texte
```


## Cartographie (sans Pointe à Pitre)

```{r}
cogGEOM <- st_read("data/geo.gpkg", "cog") 
cogGEOM <- cogGEOM [-72,]
```

```{r}
fond <- st_read("data/gros/DEPARTEMENT.shp")
png("img/communes.png")
mf_init(cogGEOM)
mf_map(fond, add = T, col = "antiquewhite1", border = "wheat")
mf_map(cogGEOM, col = "red", border = NA,add = T)
mf_layout("Communes choisies par les étudiants (sf Pointe à Pitre (Guadeloupe))", credits = "IGN")
dev.off()
```

![](img/communes.png)

Des choix sur toute l’étendue du territoire de la métropole


# Extraction des données

```{r}
cog <- read.csv("data/cog.csv", colClasses = "character")
```



## Données spatiales

### bv

```{r}
bv <- st_read("data/gros/bureau-de-vote-insee-reu-openstreetmap.gpkg")
bv <- bv [, c("insee", "nom", "bureau")]
bv <- st_transform(bv, 2154)
bvSel <- bv [bv$insee %in% cog$INSEE_COM,]
length(unique(bvSel$insee))
manquants <- setdiff(cog$INSEE_COM, bv$insee)
```

pb Marseille 1er et Lyon 1er

le fichier des bureaux de vote utilise le code INSEE ville

les codes insee sont les codes des villes (le code arr est sur le champs bureau)

```{r}
# filtre sur les 2 communes avec les codes INSEE
pb <- bv [bv$insee %in% c('13055', '69123'),]
# on extrait les codes insee de la variable bureau
pb$insee <- substring(pb$bureau, 1,5)
pb <- pb [pb$insee %in% c('13201','69381'),]
# on extrait le numéro du bureau
pb$bureau2 <- substring(pb$bureau, 7,9)
# extraction sur le libelle
pbMarseille <- pb [pb$nom == 'Marseille',]
# verif un bureau par nom bureau
table(pbMarseille$bureau2)
#  bureaux à Marseille
bureauxMarseille <- names(tab)
bureauxMarseille
# 18 bureaux ms pas nom se suivant
pbLyon <- pb [pb$nom == 'Lyon',]
# 16 bureaux Lyon 101 117
table(pbLyon$bureau2)
pb <- pb [, -5]
bvSel <- rbind(bvSel, pb)
```

Cartographie de Marseille pour voir logique des nom de bureau

```{r}
st_write(pbMarseille,"data/pb.gpkg", "bureauxMarseille", delete_layer = T)
png("img/pbMarseille.png")
mf_map(pbMarseille, col = "antiquewhite2")
mf_label(pbMarseille, var = "bureau2", cex = 1.5, halo = T)
mf_layout("Marseille : des bureaux discontinues", "opendata REU")
dev.off()
```


![](img/pbMarseille.png)
Ville à un seul bv : uniquement Drom

```{r}
tab <- sort(table (bvSel$insee))
hist(tab, main = "Distribution du nombre de bureaux sur les 72 villes", xlab = "nb de bureaux",
     ylab = "nb de villes")
bvSel$bureau [bvSel$nom == "Drom"] <- 1
bvSel$bureau [bvSel$nom == "Drom"]
```

2849 bureaux au total

enregistrement

```{r}
st_write(bvSel, "data/gros/geo.gpkg", "bv", delete_layer = T)
```

### Iris


```{r}
iris <- st_read("data/gros/IRIS-GE_3-0_SHP_LAMB93_FXX-ED2023-01-01/IRIS.shp")
```

```{r}
names(iris)
# verif code INSEE
iris$INSEE_COM
# filtre
irisSel <- iris [iris$INSEE_COM %in% cog$INSEE_COM,]
length(unique(irisSel$INSEE_COM))
manquants <- setdiff(cog$INSEE_COM, irisSel$INSEE_COM)
cog$NOM_COM_M [cog$INSEE_COM %in% manquants]
```

rajout Pointe à pitre

pb projection....on garde à part

```{r}
iris <- st_read("data/gros/IRIS-GE_3-0_SHP_RGAF09UTM20_GLP-ED2023-01-01/IRIS.shp")
irisPAP <- iris [iris$NOM_COM == 'Pointe-à-Pitre',]
```



enregistrement

```{r}
st_write(irisSel, "data/gros/geo.gpkg", "iris", delete_layer = T)
st_write(irisPAP, "data/gros/geo.gpkg", "irisPAP", delete_layer = T)
```










Des choix sur toute l'étendue du territoire de la métropole









### Carreaux Filosofi

```{r}
library(sf)
library(mapsf)
car <- st_read("data/gros/carreaux_200m_met.gpkg")
# extraction du premier code insee du carreau + la quote pour pb zero
car$cog <- paste0("'",substring(car$lcog_geo,1,5))
carSel <- car [car$cog %in% cog$INSEE_COM_TXT,]
length(unique(carSel$cog))
```

toujours 71


Bondy


```{r}
bondy <- carSel [carSel$lcog_geo == '93010',]
plot(bondy$men_pauv, bondy$men_mais)
hist(bondy$men_pauv)
str(bondy)
```

Enregistrement des carreaux par dpt

```{r}
st_write(carSel, "data/gros/geo.gpkg", "car", delete_layer = T)
```

16 M carreaux

```{r}
valDpt <- unique(vfSel$Code.departement)
carSel$dpt <- substring(carSel$lcog_geo,1,2)
carSel <- carSel [,c(37,1:33), drop = T]
for (i in valDpt){
  sel <- carSel [carSel$dpt == i,]
  write.csv2(sel, paste0("data/examen/car/", i, "_carEXAMEN.csv"), fileEncoding = "UTF-8")
}
```

## RPLS

Le RPLS est par région et par dpt en idf

```{r}
fic <- list.files("data/gros/RPLS")
regFic <- substring(fic, 28,29)
refRPLS <- data.frame(reg = regFic, fic = fic)
refRPLS
# equiv code insee et region
ref <- read.csv("data/gros/table-appartenance-geo-communes-23.csv", fileEncoding = "UTF-8")
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8")
cog$INSEE_COM <- substring(cog$INSEE_COM_TXT, 2, 6)
joint <- merge(cog, ref [, c("CODGEO", "REG", "DEP")], by.x = "INSEE_COM", by.y = "CODGEO")
reg <-names(table(joint$REG))
# 12 régions sur 19
r <- reg [1]
reg <- reg [-c(1:3)]
rpls <- NULL
for (r in reg){
  refFIC <- refRPLS$fic [refRPLS$reg == r]
  print(r)
  fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), header = T, quote = "")
  commune <- joint$INSEE_COM [joint$REG == r] 
  for (c in commune){
     tmp <-  fic [fic$DEPCOM == c,]
     rpls <- rbind (rpls, tmp)
  }
  }
write.csv(rpls, "data/gros/rpls.csv")
head(rpls)
```

pb lecture reg27

```{r}
fic <- read.csv2(paste0("data/gros/RPLS/", refFIC), quote="")
write.csv(fic, paste0("data/gros/RPLS", refFIC), fileEncoding = "UTF-8", quote = "")
```


## Données texte

### résultats des élections 2022



```{r, eval=FALSE}
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8", colClasses = "character")
# jointure ville code insee pour les résultats
election2022 <- read.csv("data/gros/resultats-par-niveau-burvot-t1-france-entiere.csv", fileEncoding = "UTF-8", header = T, colClasses = "character")
names(election2022)
str(election2022$Code.de.la.commune)
# INSEE_COM code insee
election2022$INSEE_COM<-paste0(election2022$Code.du.département,election2022$Code.de.la.commune)
# Pb pointe à pitre
election2022[grep("Pointe-à-Pitre", election2022$Libellé.de.la.commune),]
# le code dpt est ZA120 on le remplace par le cog officiel
election2022$INSEE_COM[election2022$INSEE_COM =="ZA120"] <- 97120
# extraction
election2022 <- election2022 [election2022$INSEE_COM %in% cog$INSEE_COM,]
length(unique(election2022$INSEE_COM))
# 72 youpi au cas où ce n'est pas le cas :
pb <- setdiff(cog$INSEE_COM, filtre$INSEE_COM)
cog[cog$INSEE_COM %in% pb ,]
```



```{r}
# ok Lyon 69 123 et Marseille 13 055
lyon <- election2022 [election2022$INSEE_COM == "69123",]
lyon$Code.du.b.vote <- as.integer(lyon$Code.du.b.vote)
lyon <- lyon [lyon$Code.du.b.vote %in% c(101:117),]
lyon$INSEE_COM <- "69381"
# joint on retire puis on ajoute
election2022 <- election2022 [election2022$INSEE_COM != "69123",]
election2022 <- rbind(election2022, lyon)
```

idem pour Marseille

```{r}
mars <- election2022 [election2022$INSEE_COM == "13055",]
mars$Code.du.b.vote <- as.integer(mars$Code.du.b.vote)
# recup des libellés bv
tmp <- sort(mars$Code.du.b.vote)
tmp <- tmp [1:18]
mars <- mars [mars$Code.du.b.vote %in% tmp,]
mars$INSEE_COM <- "13201"
# joint on retire puis on ajoute
election2022 <- election2022 [election2022$INSEE_COM != "13055",]
election2022 <- rbind(election2022, mars)
```



```{r}
write.csv(election2022,"data/election2022.csv", fileEncoding = "UTF-8", row.names = FALSE)
```



remplacer les en têtes par les noms, on extrait les candidats

le remplacement se fera en fonction des colonnes choisies % ou inscrits ou sexe etc...

```{r}
election2022 <- read.csv("data/election2022.csv", fileEncoding = "UTF-8")
ind <- grep("Nom", names(election2022))
candidats  <- t(unique(election2022[, c(ind)]))
candidats <- as.vector(candidats)
write.csv(candidats,"data/candidats.csv")
```






Agrégation par point adresse




### Valeurs foncières



```{r}
cog <- read.csv("data/cog.csv", colClasses = "character", fileEncoding = "UTF-8")
cog$INSEE_COM
vf <- read.csv("data/gros/valeursfoncieres-2022.txt", sep ="|", dec = ",", fileEncoding = "UTF-8")
```

attention gros fichier

code INSEE

pb des zéros, un import en txt n'a pas réglé la question.


```{r}
names(vf)
vf$lg <- sapply(vf$Code.commune, nchar)
vf$dpt <- sapply(vf$Code.departement, nchar)
table(vf$dpt)
table(vf$Code.departement [vf$dpt == "3"])
# on supprime les  sf pointe à pitre
vf[grep("POINTE A PITRE", vf$Commune),]
vf$dpt[grep("POINTE A PITRE", vf$Commune)] <-  2
vf<- vf [vf$dpt < 3, ] 
table(vf$lg, useNA = "always")
# pour le code commune on rajoute deux zéros et on coupe
vf$com <- paste0('00', vf$Code.commune)
table(sapply(vf$com, nchar))
right = function (string, char) {
    substr(string,nchar(string)-(char-1),nchar(string))
}
vf$comF <- right(vf$com, 3)
table(sapply(vf$comF, nchar))
# cas pointe à pitre
vf$cog <- paste0(vf$Code.departement, vf$comF)
table(sapply(vf$cog, nchar))
vf$cog [nchar(vf$cog)==6] <- "97120"
```

extraction des 72 communes


```{r}
vfSel <- vf [vf$cog %in% cog$INSEE_COM,]
length(unique(vfSel$cog))
```

68 communes
On rajoute les premiers arrondissements de Marseille et Lyon (au cas où mais normalement le cog a été modifie)

```{r}
manquants <- setdiff(cog$INSEE_COM, vfSel$cog)
cog$Libellé.de.la.commune [cog$INSEE_COM %in% manquants]
vfSel [vfSel$cog == '69381',]
vf$cog [grep("^LYON 1", vf$Commune)]
```

Marseille et Lyon trop grands. Thionville pas de valeur foncière

```{r}
vf [grep("MARSEILLE", vf$Commune), c("cog","Commune")]
# Pour Marseille, on prend le 1er 13201
vf [grep("^THIONVILLE", vf$Commune), c("cog","Commune")]
vf [vf$cog == 57672,]
# Les DVF pour l'Alsace Moselle dans le livre foncier droit local pas d'appli
vf [grep("^LYON", vf$Commune), c("cog","Commune")]
# Pour Lyon, le 69381
manquants <- c("13201", "69381")
```

```{r}
autres <- vf [vf$cog %in% manquants,]
vfSel <- rbind(vfSel, autres)
```

test bondy

```{r}
bondy <- vfSel [vfSel$cog == "'93010",]
tab <- table(bondy$Valeur.fonciere)
hist(bondy$Valeur.fonciere)
table(bondy$Voie [bondy$Valeur.fonciere > 30000000])
barplot(table(bondy$Voie [bondy$Valeur.fonciere < 3000]), las = 2)
```





```{r}
names(vfSel)
write.csv(vfSel [, c(48,1:43)], "data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
```


on enregistre par dpt


```{r}
valDpt <- unique(vfSel$Code.departement)
for (i in valDpt){
  sel <- vfSel [vfSel$Code.departement == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/vf/", i, "_vfEXAMEN.csv"), fileEncoding = "UTF-8")
}
```



###  Base logement (IRIS)



```{r}
lgt <- read.csv2("data/gros/base-ic-logement-2019.CSV", dec = ".")
lgt$INSEE_CODE_TXT <- paste0("'", lgt$COM)
# rajout Marseille 1 et Lyon 1 13201 69381
ajout1 <- c("'13201", "Marseille 1")
ajout2 <- c("'69381", "Lyon 1")
cog <- rbind(cog, ajout1, ajout2)
lgtSel <- lgt [lgt$INSEE_CODE_TXT %in% cog$INSEE_COM_TXT,]
length(unique(lgtSel$COM))
```

71 communes

test Bondy


```{r}
bondy <- lgtSel [lgtSel$COM == '93010',]
plot(bondy$P19_LOGVAC, bondy$P19_MAISON)
```


enregistrement

```{r}
write.csv(lgtSel, "data/gros/lgt.csv", fileEncoding = "UTF-8")
valDpt <- unique(vfSel$Code.departement)
lgtSel$dpt <- substring(lgtSel$COM,1,2)
for (i in valDpt){
  sel <- lgtSel [lgtSel$dpt == i,]
  write.csv2(sel [, c(48,1:43)], paste0("data/examen/lgt/", i, "_lgtEXAMEN.csv"), fileEncoding = "UTF-8")
}
```




# Agrégation par bureaux de vote

On a déjà les bv et les carreaux

```{r}
st_layers("data/gros/geo.gpkg")
```


## Spatialisation

lgt.csv à l'IRIS 
vf.csv  à la parcelle
le rpls à l'appartement

### données

#### csv

```{r}
vf <- read.csv("data/gros/vfEXAMEN.csv", fileEncoding = "UTF-8")
lgt <- read.csv("data/gros/lgt.csv", fileEncoding = "UTF-8")
rpls <- list.files("data/gros/RPLS")
cog <- read.csv("data/cog.csv", fileEncoding = "UTF-8", colClasses = "character")
```

#### spatiaux



###  vf / parcelle

On récupère le cadastre, on intersecte parcelle et bv et on enregistre le fichier
dans bv.gpkg avec le code insee.

```{r}
dpt <- substring(cog$INSEE_COM_TXT,2,3)
code <- substring(cog$INSEE_COM_TXT,2,6)
bv <- bv [bv$insee %in% code,]
code
dpt <- dpt [1:length(dpt)]
code <- code [1:length(code)]

for (i in 15:length(dpt)){
  nomZIP <- paste0(dpt [i], "_", code [i],".gz")
  nomGEO <- paste0(dpt [i], "_", code [i],".geojson")
  print(paste0(i, "_",nomZIP))
  if (file.exists(nomZIP)==FALSE ){
    fic <- download.file(paste0("https://cadastre.data.gouv.fr/data/etalab-cadastre/2023-07-01/geojson/communes/", dpt [i],"/",code [i],"/cadastre-", code [i],"-parcelles.json.gz"), nomZIP)
  }
  
  exdir <- paste0("data/gros/cadastre/",nomGEO)
  gunzip(nomZIP, exdir, overwrite = T )
  cadastre <- st_read(paste0("data/gros/cadastre/",nomGEO))
  cadastre <- st_transform(cadastre,2154)
  # extraction bv
  bvSel <- bv [bv$insee == code [i],]
  all(sf::st_is_valid(bvSel))
  bvSel <- st_make_valid(bvSel)
  # intersection avec bv
  inter <- st_intersection(bvSel [, c("bureau")], st_centroid( cadastre [, c("section", "numero")]))
  st_write(inter, "data/gros/bv.gpkg", paste0("bv_",code [i]), delete_layer = T)
}
```


bilan

```{r}
st_layers("data/gros/bv.gpkg")
# 64 couches dont bv69381 (lyon) vide
vf <- vf [vf$Code.departement == '69',]
vf$Code.commune [grep('381', vf$Code.commune)]
table(vf$Code.commune)
```



## lgt / iris





Croisement iris / bv

```{r}
inter <- st_intersection(bv, irisSel)
```



```{r}

```

